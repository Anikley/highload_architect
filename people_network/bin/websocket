#!/usr/bin/env node
/* eslint-disable no-console */
/* eslint-disable no-undef */
var WebSocketServer = require("websocket").server;
var http = require("http");
const NodeCache = require( "node-cache" );
const kafka = require("kafka-node");

const sql = require("../db");

//кеш
let cache_news = new NodeCache({ stdTTL: 100000, checkperiod:600 });

const KafkaClient = new kafka.KafkaClient("localhost:2181", "localhost:9092" );

var server = http.createServer(function(request, response) {
    console.log((new Date()) + " Received request for " + request.url);
    response.writeHead(404);
    response.end();
});
server.listen(5000, function() {
    console.log((new Date()) + " Server is listening on port 5000");
});

wsServer = new WebSocketServer({
    httpServer: server,

    autoAcceptConnections: false
});

function originIsAllowed(origin) {
    return true;
}


/**
 * Выбрать все новости для пользователя
 * consumerGroup - чьи топики читаем
 * каждый топик отвечает за автора обновлений
 */
function getAll() {
    try {
        const options = {
            autoCommit: false,
        };

        // чтение всех сообщений разом и фильтрация только в момент создания ленты
        const consumer =  new kafka.Consumer(KafkaClient, [{ topic: "messages", partition: 0 }], options);
        getCachedNews();
        consumer.on("message", (data) => {

            const oldNews = cache_news.take("messages");
            const updatedNews = [].concat([JSON.parse(data.value)], oldNews.ms);
            cache_news.set("messages", { ms: updatedNews });
        });

        return;
    }
    catch (err ) {
        console.log("error: ", err);
    }
}

// получить из кеша ленту обновлений
function getCachedNews () {
    if (cache_news.has("messages")) {
        return cache_news.get("messages");
    }
    else {
        cache_news.set("messages", { ms: []});
        return undefined;
    }
}

function getMessageCount() {
    if (cache_news.has("messagesCount")) {
        return cache_news.get("messagesCount");
    }
    else {
        cache_news.set("messagesCount", -1);
        return cache_news.get("messagesCount");
    }
}

function getAllFriends (mylogin) {
    return new Promise((resolve, reject) => {
        sql.query(
            `SELECT * FROM person JOIN  (SELECT links.Person1_ID, links.Person2_ID FROM links WHERE ( links.Person1_ID in (SELECT Id FROM person WHERE person.Login = '${mylogin}') OR links.Person2_ID in ((SELECT Id FROM person WHERE person.Login = '${mylogin}')))) as res WHERE (res.Person1_ID = person.Id OR res.Person2_ID = person.Id) AND person.Login <> '${mylogin}'`,
            (err, result) => {
                if (err) {
                    // eslint-disable-next-line no-console
                    console.log("error: ", err);
                    reject(err);
                }
                if (!err) resolve(JSON.parse(JSON.stringify(result)));
            }
        );
    });
}

wsServer.on("request", async (request) => {
    if (!originIsAllowed(request.origin)) {
        request.reject();
        console.log((new Date()) + " Connection from origin " + request.origin + " rejected.");
        return;
    }
    var cachedfriends = await getAllFriends(request.resourceURL.pathname.substring(1, request.resourceURL.pathname.length));
    getAll();

    var connection = request.accept("echo-protocol", request.origin);

    connection.on("message", async (message) => {
        setInterval(() => {
            const cachedlentaNews = getCachedNews();

            if (cachedlentaNews !== undefined)
            {
                if (cachedlentaNews.ms.length === getMessageCount()) return;

                const ar = ((cachedlentaNews.ms).filter(x => (cachedfriends.map(x => x.ID.toString())).includes(x.PersonId)));
                cache_news.set("messagesCount", cachedlentaNews.ms.length);

                connection.sendUTF(JSON.stringify(ar));
            }
        }, 2000);
    });

    connection.on("close", function(reasonCode, description) {
        console.log((new Date()) + " Peer " + connection.remoteAddress + " disconnected.");
    });
});